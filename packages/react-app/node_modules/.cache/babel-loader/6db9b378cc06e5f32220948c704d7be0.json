{"ast":null,"code":"var ethers = require('ethers');\n\nvar fs = require('fs');\n\nconst ProviderEngine = require('web3-provider-engine');\n\nconst CacheSubprovider = require('web3-provider-engine/subproviders/cache.js');\n\nconst FixtureSubprovider = require('web3-provider-engine/subproviders/fixture.js');\n\nconst FilterSubprovider = require('web3-provider-engine/subproviders/filters.js');\n\nconst HookedWalletSubprovider = require('web3-provider-engine/subproviders/hooked-wallet-ethtx.js'); // const VmSubprovider = require('web3-provider-engine/subproviders/vm.js')\n\n\nconst NonceSubprovider = require('web3-provider-engine/subproviders/nonce-tracker.js');\n\nconst RpcSubprovider = require('web3-provider-engine/subproviders/rpc.js');\n\nconst WebSocketSubProvider = require('web3-provider-engine/subproviders/websocket.js');\n\nconst sigUtil = require('eth-sig-util');\n\nmodule.exports = BurnerProvider;\nlet metaAccount;\n\nfunction BurnerProvider(opts = {}) {\n  var engine = new ProviderEngine();\n  let provider = new ethers.providers.Web3Provider(engine); // let them pass in a simple string for the options and use that as infura or whatevs\n\n  if (typeof opts == \"string\") {\n    let rpcUrl = opts;\n    opts = {\n      rpcUrl\n    };\n  }\n\n  let privateKeyStorageString = \"metaPrivateKey\";\n\n  if (opts.namespace) {\n    privateKeyStorageString = privateKeyStorageString + \"_\" + opts.namespace;\n  }\n\n  if (opts && opts.privateKey) {\n    //if they passed in a private key, use it to generate an account\n    //metaAccount = provider.eth.accounts.privateKeyToAccount(opts.privateKey)\n    metaAccount = new ethers.Wallet(opts.privateKey, provider); //console.log(\"metaAccount from pk\",metaAccount)\n  } else if (typeof localStorage != \"undefined\" && typeof localStorage.setItem == \"function\") {\n    //load private key out of local storage\n    let metaPrivateKey = localStorage.getItem(privateKeyStorageString);\n    if (metaPrivateKey == \"0\") metaPrivateKey = false;\n    if (metaPrivateKey && metaPrivateKey.length !== 66) metaPrivateKey = false; //if(metaPrivateKey) metaAccount = provider.eth.accounts.privateKeyToAccount(metaPrivateKey)\n\n    if (metaPrivateKey) metaAccount = new ethers.Wallet(metaPrivateKey, provider);\n  } else {\n    //local storage isn't an option and they didn't pass in a pk attempted to use the filesystem\n    try {\n      let fsPk = fs.readFileSync(\".pk\").toString();\n\n      if (fsPk) {\n        metaAccount = new ethers.Wallet(fsPk, provider);\n      }\n    } catch (e) {} // if not just generate a temp account in memory for this session\n    // (just leave metaAccount false and it will be created in the next block)\n\n  }\n\n  if (!metaAccount) {\n    //generate account either from a provided mnemonic, pk, or random generation\n    if (opts.mnemonic) {\n      const bip39 = require('bip39');\n\n      const hdkey = require('ethereumjs-wallet/hdkey');\n\n      let index = \"0\";\n\n      if (typeof opts.index != \"undefined\") {\n        index = opts.index;\n      }\n\n      const seed = bip39.mnemonicToSeedSync(opts.mnemonic);\n      const hdwallet = hdkey.fromMasterSeed(seed);\n      const wallet_hdpath = \"m/44'/60'/0'/0/\";\n      const wallet = hdwallet.derivePath(wallet_hdpath + index).getWallet();\n      const privateKey = \"0x\" + wallet.getPrivateKey().toString(\"hex\"); //metaAccount = provider.eth.accounts.privateKeyToAccount(privateKey)\n\n      metaAccount = new ethers.Wallet(privateKey, provider);\n    } else {\n      //metaAccount = provider.eth.accounts.create();\n      metaAccount = ethers.Wallet.createRandom();\n    } //if we needed to generate, save the pk to local storage\n\n\n    if (typeof localStorage != \"undefined\" && typeof localStorage.setItem == \"function\") {\n      localStorage.setItem(privateKeyStorageString, metaAccount.privateKey);\n    } else {\n      //if we can't use local storage try saving it to the filesystem\n      try {\n        fs.writeFileSync(\".pk\", metaAccount.privateKey);\n      } catch (e) {}\n    }\n  }\n\n  opts.getPrivateKey = (address, cb) => {\n    if (address.toLowerCase() == metaAccount.address.toLowerCase()) {\n      cb(null, Buffer.from(metaAccount.privateKey.replace(\"0x\", \"\"), 'hex'));\n    } else {\n      cb(\"unknown account\");\n    }\n  };\n\n  opts.getAccounts = cb => {\n    //console.log(\"metaAccount\",metaAccount)\n    cb(false, [metaAccount.address]);\n  }; // static results\n\n\n  engine.addProvider(new FixtureSubprovider({\n    web3_clientVersion: 'ProviderEngine/v0.0.0/javascript',\n    net_listening: true,\n    eth_hashrate: '0x00',\n    eth_mining: false,\n    eth_syncing: true\n  })); // cache layer\n\n  engine.addProvider(new CacheSubprovider()); // filters\n\n  engine.addProvider(new FilterSubprovider()); // pending nonce\n\n  engine.addProvider(new NonceSubprovider()); // vm\n  // engine.addProvider(new VmSubprovider())\n  // id mgmt\n\n  const hookedWalletSubprovider = new HookedWalletSubprovider(opts);\n\n  hookedWalletSubprovider.signTypedMessage = function (msgParams, cb) {\n    opts.getPrivateKey(msgParams.from, function (err, privateKey) {\n      if (err) return cb(err);\n      const serialized = sigUtil.signTypedData_v4(privateKey, msgParams);\n      cb(null, serialized);\n    });\n  };\n\n  engine.addProvider(hookedWalletSubprovider);\n\n  if (opts.rpcUrl.indexOf(\"wss://\") == 0) {\n    engine.addProvider(new WebSocketSubProvider(opts));\n  } else {\n    // data source\n    engine.addProvider(new RpcSubprovider(opts));\n  } // start polling for blocks\n\n\n  engine.start();\n  return engine;\n}","map":{"version":3,"sources":["C:/Users/chris/Documents/Workspace/xanadu-contracts/scaffold-eth/node_modules/burner-provider/index.js"],"names":["ethers","require","fs","ProviderEngine","CacheSubprovider","FixtureSubprovider","FilterSubprovider","HookedWalletSubprovider","NonceSubprovider","RpcSubprovider","WebSocketSubProvider","sigUtil","module","exports","BurnerProvider","metaAccount","opts","engine","provider","providers","Web3Provider","rpcUrl","privateKeyStorageString","namespace","privateKey","Wallet","localStorage","setItem","metaPrivateKey","getItem","length","fsPk","readFileSync","toString","e","mnemonic","bip39","hdkey","index","seed","mnemonicToSeedSync","hdwallet","fromMasterSeed","wallet_hdpath","wallet","derivePath","getWallet","getPrivateKey","createRandom","writeFileSync","address","cb","toLowerCase","Buffer","from","replace","getAccounts","addProvider","web3_clientVersion","net_listening","eth_hashrate","eth_mining","eth_syncing","hookedWalletSubprovider","signTypedMessage","msgParams","err","serialized","signTypedData_v4","indexOf","start"],"mappings":"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","sourcesContent":["var ethers = require('ethers');\nvar fs = require('fs');\nconst ProviderEngine = require('web3-provider-engine')\nconst CacheSubprovider = require('web3-provider-engine/subproviders/cache.js')\nconst FixtureSubprovider = require('web3-provider-engine/subproviders/fixture.js')\nconst FilterSubprovider = require('web3-provider-engine/subproviders/filters.js')\nconst HookedWalletSubprovider = require('web3-provider-engine/subproviders/hooked-wallet-ethtx.js')\n// const VmSubprovider = require('web3-provider-engine/subproviders/vm.js')\nconst NonceSubprovider = require('web3-provider-engine/subproviders/nonce-tracker.js')\nconst RpcSubprovider = require('web3-provider-engine/subproviders/rpc.js')\nconst WebSocketSubProvider = require('web3-provider-engine/subproviders/websocket.js')\n\nconst sigUtil = require('eth-sig-util')\n\nmodule.exports = BurnerProvider\n\nlet metaAccount\n\nfunction BurnerProvider(opts = {}){\n  var engine = new ProviderEngine()\n  let provider = new ethers.providers.Web3Provider(engine)\n\n  // let them pass in a simple string for the options and use that as infura or whatevs\n  if(typeof opts == \"string\"){\n    let rpcUrl = opts\n    opts = {rpcUrl}\n  }\n\n  let privateKeyStorageString = \"metaPrivateKey\"\n  if(opts.namespace){\n    privateKeyStorageString = privateKeyStorageString+\"_\"+opts.namespace\n  }\n\n  if(opts&&opts.privateKey){\n    //if they passed in a private key, use it to generate an account\n    //metaAccount = provider.eth.accounts.privateKeyToAccount(opts.privateKey)\n    metaAccount = new ethers.Wallet(opts.privateKey, provider);\n    //console.log(\"metaAccount from pk\",metaAccount)\n  } else if(typeof localStorage != \"undefined\"&&typeof localStorage.setItem == \"function\"){\n    //load private key out of local storage\n    let metaPrivateKey = localStorage.getItem(privateKeyStorageString)\n    if(metaPrivateKey==\"0\") metaPrivateKey=false;\n    if(metaPrivateKey && metaPrivateKey.length!==66) metaPrivateKey=false;\n    //if(metaPrivateKey) metaAccount = provider.eth.accounts.privateKeyToAccount(metaPrivateKey)\n    if(metaPrivateKey) metaAccount = new ethers.Wallet(metaPrivateKey, provider);\n  }else{\n    //local storage isn't an option and they didn't pass in a pk attempted to use the filesystem\n    try{\n      let fsPk = fs.readFileSync(\".pk\").toString()\n      if(fsPk){\n        metaAccount = new ethers.Wallet(fsPk, provider);\n      }\n    }catch(e){}\n    // if not just generate a temp account in memory for this session\n    // (just leave metaAccount false and it will be created in the next block)\n  }\n\n  if(!metaAccount){\n    //generate account either from a provided mnemonic, pk, or random generation\n    if(opts.mnemonic){\n      const bip39 = require('bip39');\n      const hdkey = require('ethereumjs-wallet/hdkey');\n      let index = \"0\"\n      if(typeof opts.index != \"undefined\"){\n        index = opts.index\n      }\n      const seed = bip39.mnemonicToSeedSync(opts.mnemonic);\n      const hdwallet = hdkey.fromMasterSeed(seed);\n      const wallet_hdpath = \"m/44'/60'/0'/0/\";\n      const wallet = hdwallet.derivePath(wallet_hdpath + index).getWallet();\n      const privateKey =\"0x\"+wallet.getPrivateKey().toString(\"hex\")\n      //metaAccount = provider.eth.accounts.privateKeyToAccount(privateKey)\n      metaAccount = new ethers.Wallet(privateKey, provider);\n    }else{\n      //metaAccount = provider.eth.accounts.create();\n      metaAccount = ethers.Wallet.createRandom()\n    }\n    //if we needed to generate, save the pk to local storage\n    if(typeof localStorage != \"undefined\"&&typeof localStorage.setItem == \"function\"){\n      localStorage.setItem(privateKeyStorageString,metaAccount.privateKey)\n    }else{\n      //if we can't use local storage try saving it to the filesystem\n      try{\n        fs.writeFileSync(\".pk\",metaAccount.privateKey)\n      }catch(e){}\n    }\n  }\n\n  opts.getPrivateKey = (address,cb)=>{\n    if(address.toLowerCase()==metaAccount.address.toLowerCase()){\n      cb(null,Buffer.from(metaAccount.privateKey.replace(\"0x\",\"\"),'hex'))\n    }else{\n      cb(\"unknown account\")\n    }\n  }\n\n  opts.getAccounts = (cb)=>{\n    //console.log(\"metaAccount\",metaAccount)\n    cb(false,[metaAccount.address])\n  }\n\n  // static results\n  engine.addProvider(new FixtureSubprovider({\n    web3_clientVersion: 'ProviderEngine/v0.0.0/javascript',\n    net_listening: true,\n    eth_hashrate: '0x00',\n    eth_mining: false,\n    eth_syncing: true,\n  }))\n\n\n  // cache layer\n  engine.addProvider(new CacheSubprovider())\n\n  // filters\n  engine.addProvider(new FilterSubprovider())\n\n  // pending nonce\n  engine.addProvider(new NonceSubprovider())\n\n  // vm\n  // engine.addProvider(new VmSubprovider())\n\n  // id mgmt\n  const hookedWalletSubprovider = new HookedWalletSubprovider(opts)\n\n  hookedWalletSubprovider.signTypedMessage = function (msgParams, cb) {\n    opts.getPrivateKey(msgParams.from, function(err, privateKey) {\n      if (err) return cb(err)\n      const serialized = sigUtil.signTypedData_v4(privateKey, msgParams)\n      cb(null, serialized)\n    })\n  }\n  engine.addProvider(hookedWalletSubprovider)\n\n\n\n  if(opts.rpcUrl.indexOf(\"wss://\")==0){\n    engine.addProvider(new WebSocketSubProvider(opts))\n  }else{\n    // data source\n    engine.addProvider(new RpcSubprovider(opts))\n  }\n\n  // start polling for blocks\n  engine.start()\n\n  return engine\n}\n"]},"metadata":{},"sourceType":"script"}